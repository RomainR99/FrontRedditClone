{"version":3,"sources":["../src/index.ts","../src/version.ts","../src/ClientSideSuspense.tsx","../src/liveblocks.tsx","../src/comments/lib/selected-inbox-notifications.ts","../src/lib/retry-error.ts","../src/shared.ts","../src/room.tsx","../src/comments/errors.ts","../src/comments/lib/createIds.ts","../src/comments/lib/select-notification-settings.ts","../src/comments/lib/selected-threads.ts","../src/lib/use-initial.ts","../src/lib/use-latest.ts","../src/lib/use-rerender.ts"],"names":["kInternal","makePoller","nanoid","React","createContext","useCallback","useContext","useEffect","useSyncExternalStore","useSyncExternalStoreWithSelector","console","applyOptimisticUpdates","useState","options","room","other","rootOrNull","subscribers","comment","state","err","metadata","mentionSuggestions","inboxNotification","settings","ContextBundle","POLLING_INTERVAL","shallow"],"mappings":"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","sourcesContent":["import { detectDupes } from \"@liveblocks/core\";\n\nimport { PKG_FORMAT, PKG_NAME, PKG_VERSION } from \"./version\";\n\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\nexport { ClientSideSuspense } from \"./ClientSideSuspense\";\nexport {\n  createLiveblocksContext,\n  useLiveblocksContextBundle,\n} from \"./liveblocks\";\nexport { createRoomContext, useRoomContextBundle } from \"./room\";\nexport { useSharedContextBundle } from \"./shared\";\nexport type { MutationContext, UseThreadsOptions } from \"./types\";\n\n// Re-exports from @liveblocks/client, for convenience\nexport type { Json, JsonObject } from \"@liveblocks/client\";\nexport { shallow } from \"@liveblocks/client\";\n","declare const __VERSION__: string;\ndeclare const TSUP_FORMAT: string;\n\nexport const PKG_NAME = \"@liveblocks/react\";\nexport const PKG_VERSION = typeof __VERSION__ === \"string\" && __VERSION__;\nexport const PKG_FORMAT = typeof TSUP_FORMAT === \"string\" && TSUP_FORMAT;\n","import type { ReactElement, ReactNode } from \"react\";\nimport * as React from \"react\";\n\ntype Props = {\n  fallback: NonNullable<ReactNode> | null;\n  children: () => ReactNode | undefined;\n};\n\n/**\n * Almost like a normal <Suspense> component, except that for server-side\n * renders, the fallback will be used.\n *\n * The child props will have to be provided in a function, i.e. change:\n *\n *   <Suspense fallback={<Loading />}>\n *     <MyRealComponent a={1} />\n *   </Suspense>\n *\n * To:\n *\n *   <ClientSideSuspense fallback={<Loading />}>\n *     {() => <MyRealComponent a={1} />}\n *   </ClientSideSuspense>\n *\n */\nexport function ClientSideSuspense(props: Props): ReactElement {\n  const [mounted, setMounted] = React.useState(false);\n\n  React.useEffect(() => {\n    // Effects are never executed on the server side. The point of this is to\n    // delay the flipping of this boolean until after hydration has happened.\n    setMounted(true);\n  }, []);\n\n  return (\n    <React.Suspense fallback={props.fallback}>\n      {mounted ? props.children() : props.fallback}\n    </React.Suspense>\n  );\n}\n","import type {\n  BaseMetadata,\n  BaseUserMeta,\n  Client,\n  ThreadData,\n} from \"@liveblocks/client\";\nimport type {\n  CacheState,\n  CacheStore,\n  InboxNotificationData,\n  InboxNotificationDeleteInfo,\n  Store,\n  ThreadDeleteInfo,\n} from \"@liveblocks/core\";\nimport { kInternal, makePoller } from \"@liveblocks/core\";\nimport { nanoid } from \"nanoid\";\nimport type { PropsWithChildren } from \"react\";\nimport React, {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n} from \"react\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\nimport { useSyncExternalStoreWithSelector } from \"use-sync-external-store/shim/with-selector.js\";\n\nimport { selectedInboxNotifications } from \"./comments/lib/selected-inbox-notifications\";\nimport { retryError } from \"./lib/retry-error\";\nimport { createSharedContext } from \"./shared\";\nimport type {\n  InboxNotificationsState,\n  InboxNotificationsStateSuccess,\n  LiveblocksContextBundle,\n  UnreadInboxNotificationsCountState,\n  UnreadInboxNotificationsCountStateSuccess,\n} from \"./types\";\n\nexport const ContextBundle = createContext<LiveblocksContextBundle<\n  BaseUserMeta,\n  BaseMetadata\n> | null>(null);\n\n/**\n * @private\n *\n * This is an internal API, use \"createLiveblocksContext\" instead.\n */\nexport function useLiveblocksContextBundle() {\n  const bundle = useContext(ContextBundle);\n  if (bundle === null) {\n    throw new Error(\"LiveblocksProvider is missing from the React tree.\");\n  }\n  return bundle;\n}\n\nexport const POLLING_INTERVAL = 60 * 1000; // 1 minute\nexport const INBOX_NOTIFICATIONS_QUERY = \"INBOX_NOTIFICATIONS\";\n\nexport function createLiveblocksContext<\n  TUserMeta extends BaseUserMeta = BaseUserMeta,\n  TThreadMetadata extends BaseMetadata = never,\n>(client: Client): LiveblocksContextBundle<TUserMeta, TThreadMetadata> {\n  const shared = createSharedContext<TUserMeta>(client);\n\n  const store = client[kInternal]\n    .cacheStore as unknown as CacheStore<TThreadMetadata>;\n\n  const notifications = client[kInternal].notifications;\n\n  function LiveblocksProvider(props: PropsWithChildren) {\n    return (\n      <ContextBundle.Provider\n        value={\n          bundle as unknown as LiveblocksContextBundle<\n            BaseUserMeta,\n            BaseMetadata\n          >\n        }\n      >\n        {props.children}\n      </ContextBundle.Provider>\n    );\n  }\n\n  // TODO: Unify request cache\n  let fetchInboxNotificationsRequest: Promise<{\n    inboxNotifications: InboxNotificationData[];\n    threads: ThreadData<TThreadMetadata>[];\n    deletedThreads: ThreadDeleteInfo[];\n    deletedInboxNotifications: InboxNotificationDeleteInfo[];\n    meta: {\n      requestedAt: Date;\n    };\n  }> | null = null;\n  let inboxNotificationsSubscribers = 0;\n  let lastRequestedAt: Date | undefined;\n\n  const poller = makePoller(refreshThreadsAndNotifications);\n\n  function refreshThreadsAndNotifications() {\n    return notifications.getInboxNotifications({ since: lastRequestedAt }).then(\n      (result) => {\n        lastRequestedAt = result.meta.requestedAt;\n\n        store.updateThreadsAndNotifications(\n          result.threads,\n          result.inboxNotifications,\n          result.deletedThreads,\n          result.deletedInboxNotifications,\n          INBOX_NOTIFICATIONS_QUERY\n        );\n      },\n      () => {\n        // TODO: Error handling\n      }\n    );\n  }\n\n  function incrementInboxNotificationsSubscribers() {\n    inboxNotificationsSubscribers++;\n\n    poller.start(POLLING_INTERVAL);\n  }\n\n  function decrementInboxNotificationsSubscribers() {\n    if (inboxNotificationsSubscribers <= 0) {\n      console.warn(\n        `Internal unexpected behavior. Cannot decrease subscriber count for query \"${INBOX_NOTIFICATIONS_QUERY}\"`\n      );\n      return;\n    }\n\n    inboxNotificationsSubscribers--;\n\n    if (inboxNotificationsSubscribers <= 0) {\n      poller.stop();\n    }\n  }\n\n  async function fetchInboxNotifications(\n    { retryCount }: { retryCount: number } = { retryCount: 0 }\n  ) {\n    if (fetchInboxNotificationsRequest !== null) {\n      return fetchInboxNotificationsRequest;\n    }\n\n    store.setQueryState(INBOX_NOTIFICATIONS_QUERY, {\n      isLoading: true,\n    });\n\n    try {\n      fetchInboxNotificationsRequest = notifications.getInboxNotifications();\n\n      const result = await fetchInboxNotificationsRequest;\n\n      store.updateThreadsAndNotifications(\n        result.threads,\n        result.inboxNotifications,\n        result.deletedThreads,\n        result.deletedInboxNotifications,\n        INBOX_NOTIFICATIONS_QUERY\n      );\n\n      /**\n       * We set the `lastRequestedAt` to the timestamp returned by the current request if:\n       * 1. The `lastRequestedAt`has not been set\n       * OR\n       * 2. The current `lastRequestedAt` is older than the timestamp returned by the current request\n       */\n      if (\n        lastRequestedAt === undefined ||\n        lastRequestedAt > result.meta.requestedAt\n      ) {\n        lastRequestedAt = result.meta.requestedAt;\n      }\n\n      poller.start(POLLING_INTERVAL);\n    } catch (er) {\n      fetchInboxNotificationsRequest = null;\n\n      // Retry the action using the exponential backoff algorithm\n      retryError(() => {\n        void fetchInboxNotifications({\n          retryCount: retryCount + 1,\n        });\n      }, retryCount);\n\n      store.setQueryState(INBOX_NOTIFICATIONS_QUERY, {\n        isLoading: false,\n        error: er as Error,\n      });\n    }\n    return;\n  }\n\n  function useInboxNotificationsSelectorCallback(\n    state: CacheState<BaseMetadata>\n  ): InboxNotificationsState {\n    const query = state.queries[INBOX_NOTIFICATIONS_QUERY];\n\n    if (query === undefined || query.isLoading) {\n      return {\n        isLoading: true,\n      };\n    }\n\n    if (query.error !== undefined) {\n      return {\n        error: query.error,\n        isLoading: false,\n      };\n    }\n\n    return {\n      inboxNotifications: selectedInboxNotifications(state),\n      isLoading: false,\n    };\n  }\n\n  function useInboxNotifications(): InboxNotificationsState {\n    useEffect(() => {\n      void fetchInboxNotifications();\n      incrementInboxNotificationsSubscribers();\n\n      return () => decrementInboxNotificationsSubscribers();\n    }, []);\n\n    const result = useSyncExternalStoreWithSelector(\n      store.subscribe,\n      store.get,\n      store.get,\n      useInboxNotificationsSelectorCallback\n    );\n\n    return result;\n  }\n\n  function useInboxNotificationsSuspenseSelector(\n    state: CacheState<BaseMetadata>\n  ): InboxNotificationsStateSuccess {\n    return {\n      inboxNotifications: selectedInboxNotifications(state),\n      isLoading: false,\n    };\n  }\n\n  function useInboxNotificationsSuspense(): InboxNotificationsStateSuccess {\n    const query = store.get().queries[INBOX_NOTIFICATIONS_QUERY];\n\n    if (query === undefined || query.isLoading) {\n      throw fetchInboxNotifications();\n    }\n\n    if (query.error !== undefined) {\n      throw query.error;\n    }\n\n    React.useEffect(() => {\n      incrementInboxNotificationsSubscribers();\n\n      return () => {\n        decrementInboxNotificationsSubscribers();\n      };\n    }, []);\n\n    return useSyncExternalStoreWithSelector(\n      store.subscribe,\n      store.get,\n      store.get,\n      useInboxNotificationsSuspenseSelector\n    );\n  }\n\n  function selectUnreadInboxNotificationsCount(\n    state: CacheState<BaseMetadata>\n  ) {\n    let count = 0;\n\n    for (const notification of selectedInboxNotifications(state)) {\n      if (\n        notification.readAt === null ||\n        notification.readAt < notification.notifiedAt\n      ) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  function useUnreadInboxNotificationsCountSelector(\n    state: CacheState<BaseMetadata>\n  ): UnreadInboxNotificationsCountState {\n    const query = state.queries[INBOX_NOTIFICATIONS_QUERY];\n\n    if (query === undefined || query.isLoading) {\n      return {\n        isLoading: true,\n      };\n    }\n\n    if (query.error !== undefined) {\n      return {\n        error: query.error,\n        isLoading: false,\n      };\n    }\n\n    return {\n      isLoading: false,\n      count: selectUnreadInboxNotificationsCount(state),\n    };\n  }\n\n  function useUnreadInboxNotificationsCount(): UnreadInboxNotificationsCountState {\n    useEffect(() => {\n      void fetchInboxNotifications();\n      incrementInboxNotificationsSubscribers();\n\n      return () => decrementInboxNotificationsSubscribers();\n    }, []);\n\n    return useSyncExternalStoreWithSelector(\n      store.subscribe,\n      store.get,\n      store.get,\n      useUnreadInboxNotificationsCountSelector\n    );\n  }\n\n  function useUnreadInboxNotificationsCountSuspenseSelector(\n    state: CacheState<BaseMetadata>\n  ): UnreadInboxNotificationsCountStateSuccess {\n    return {\n      isLoading: false,\n      count: selectUnreadInboxNotificationsCount(state),\n    };\n  }\n\n  function useUnreadInboxNotificationsCountSuspense(): UnreadInboxNotificationsCountStateSuccess {\n    const query = store.get().queries[INBOX_NOTIFICATIONS_QUERY];\n\n    if (query === undefined || query.isLoading) {\n      throw fetchInboxNotifications();\n    }\n\n    React.useEffect(() => {\n      incrementInboxNotificationsSubscribers();\n\n      return () => {\n        decrementInboxNotificationsSubscribers();\n      };\n    }, []);\n\n    return useSyncExternalStoreWithSelector(\n      store.subscribe,\n      store.get,\n      store.get,\n      useUnreadInboxNotificationsCountSuspenseSelector\n    );\n  }\n\n  function useMarkInboxNotificationAsRead() {\n    return useCallback((inboxNotificationId: string) => {\n      const optimisticUpdateId = nanoid();\n      const readAt = new Date();\n      store.pushOptimisticUpdate({\n        type: \"mark-inbox-notification-as-read\",\n        id: optimisticUpdateId,\n        inboxNotificationId,\n        readAt,\n      });\n\n      notifications.markInboxNotificationAsRead(inboxNotificationId).then(\n        () => {\n          store.set((state) => {\n            const existingNotification =\n              state.inboxNotifications[inboxNotificationId];\n\n            // If existing notification has been deleted, we return the existing state\n            if (existingNotification === undefined) {\n              return {\n                ...state,\n                optimisticUpdates: state.optimisticUpdates.filter(\n                  (update) => update.id !== optimisticUpdateId\n                ),\n              };\n            }\n\n            return {\n              ...state,\n              inboxNotifications: {\n                ...state.inboxNotifications,\n                [inboxNotificationId]: {\n                  ...existingNotification,\n                  readAt,\n                },\n              },\n              optimisticUpdates: state.optimisticUpdates.filter(\n                (update) => update.id !== optimisticUpdateId\n              ),\n            };\n          });\n        },\n        () => {\n          // TODO: Broadcast errors to client\n          store.set((state) => ({\n            ...state,\n            optimisticUpdates: state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            ),\n          }));\n        }\n      );\n    }, []);\n  }\n\n  function useMarkAllInboxNotificationsAsRead() {\n    return useCallback(() => {\n      const optimisticUpdateId = nanoid();\n      const readAt = new Date();\n      store.pushOptimisticUpdate({\n        type: \"mark-inbox-notifications-as-read\",\n        id: optimisticUpdateId,\n        readAt,\n      });\n\n      notifications.markAllInboxNotificationsAsRead().then(\n        () => {\n          store.set((state) => ({\n            ...state,\n            inboxNotifications: Object.fromEntries(\n              Array.from(Object.entries(state.inboxNotifications)).map(\n                ([id, inboxNotification]) => [\n                  id,\n                  { ...inboxNotification, readAt },\n                ]\n              )\n            ),\n            optimisticUpdates: state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            ),\n          }));\n        },\n        () => {\n          // TODO: Broadcast errors to client\n          store.set((state) => ({\n            ...state,\n            optimisticUpdates: state.optimisticUpdates.filter(\n              (update) => update.id !== optimisticUpdateId\n            ),\n          }));\n        }\n      );\n    }, []);\n  }\n\n  function useInboxNotificationThread(\n    inboxNotificationId: string\n  ): ThreadData<TThreadMetadata> {\n    const selector = useCallback(\n      (state: CacheState<TThreadMetadata>) => {\n        const inboxNotification = state.inboxNotifications[inboxNotificationId];\n\n        if (inboxNotification === undefined) {\n          throw new Error(\n            `Inbox notification with ID \"${inboxNotificationId}\" not found`\n          );\n        }\n\n        if (inboxNotification.kind !== \"thread\") {\n          throw new Error(\n            `Inbox notification with ID \"${inboxNotificationId}\" is not of kind \"thread\"`\n          );\n        }\n\n        const thread = state.threads[inboxNotification.threadId];\n\n        if (thread === undefined) {\n          throw new Error(\n            `Thread with ID \"${inboxNotification.threadId}\" not found, this inbox notification might not be of kind \"thread\"`\n          );\n        }\n\n        return thread;\n      },\n      [inboxNotificationId]\n    );\n\n    return useSyncExternalStoreWithSelector(\n      store.subscribe,\n      store.get,\n      store.get,\n      selector\n    );\n  }\n\n  const currentUserIdStore = client[kInternal]\n    .currentUserIdStore as unknown as Store<string | null>;\n\n  function useCurrentUserId() {\n    return useSyncExternalStore(\n      currentUserIdStore.subscribe,\n      currentUserIdStore.get,\n      currentUserIdStore.get\n    );\n  }\n\n  const bundle: LiveblocksContextBundle<TUserMeta, TThreadMetadata> = {\n    LiveblocksProvider,\n\n    useInboxNotifications,\n    useUnreadInboxNotificationsCount,\n\n    useMarkInboxNotificationAsRead,\n    useMarkAllInboxNotificationsAsRead,\n\n    useInboxNotificationThread,\n\n    ...shared,\n\n    suspense: {\n      LiveblocksProvider,\n\n      useInboxNotifications: useInboxNotificationsSuspense,\n      useUnreadInboxNotificationsCount:\n        useUnreadInboxNotificationsCountSuspense,\n\n      useMarkInboxNotificationAsRead,\n      useMarkAllInboxNotificationsAsRead,\n\n      useInboxNotificationThread,\n\n      ...shared.suspense,\n    },\n\n    [kInternal]: {\n      useCurrentUserId,\n    },\n  };\n\n  return Object.defineProperty(bundle, kInternal, {\n    enumerable: false,\n  });\n}\n","import type {\n  BaseMetadata,\n  CacheState,\n  InboxNotificationData,\n} from \"@liveblocks/core\";\nimport { applyOptimisticUpdates } from \"@liveblocks/core\";\n\nexport function selectedInboxNotifications<\n  TThreadMetadata extends BaseMetadata,\n>(state: CacheState<TThreadMetadata>): InboxNotificationData[] {\n  const result = applyOptimisticUpdates(state);\n\n  return Object.values(result.inboxNotifications).sort(\n    // Sort so that the most recent notifications are first\n    (a, b) => b.notifiedAt.getTime() - a.notifiedAt.getTime()\n  );\n}\n","const MAX_ERROR_RETRY_COUNT = 5;\n\nconst ERROR_RETRY_INTERVAL = 5000; // 5 seconds\n\n/**\n * Retries an action using the exponential backoff algorithm\n * @param action The action to retry\n * @param retryCount The number of times the action has been retried\n */\nexport function retryError(action: () => void, retryCount: number) {\n  if (retryCount >= MAX_ERROR_RETRY_COUNT) return;\n\n  const timeout = Math.pow(2, retryCount) * ERROR_RETRY_INTERVAL;\n\n  setTimeout(() => {\n    void action();\n  }, timeout);\n}\n","import { type BaseUserMeta, type Client, kInternal } from \"@liveblocks/core\";\nimport { useCallback, useContext, useEffect } from \"react\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\n\nimport { ContextBundle as LiveblocksContextBundle } from \"./liveblocks\";\nimport { ContextBundle as RoomContextBundle } from \"./room\";\nimport type {\n  RoomInfoState,\n  RoomInfoStateSuccess,\n  SharedContextBundle,\n  UserState,\n  UserStateSuccess,\n} from \"./types\";\n\n/**\n * @private\n *\n * This is an internal API, use `createLiveblocksContext` or `createRoomContext` instead.\n */\nexport function useSharedContextBundle() {\n  const roomContextBundle = useContext(RoomContextBundle);\n  const liveblocksContextBundle = useContext(LiveblocksContextBundle);\n\n  if (roomContextBundle !== null) {\n    return roomContextBundle;\n  } else if (liveblocksContextBundle !== null) {\n    return liveblocksContextBundle;\n  } else {\n    throw new Error(\n      \"LiveblocksProvider or RoomProvider are missing from the React tree.\"\n    );\n  }\n}\n\nconst missingUserError = new Error(\n  \"resolveUsers didn't return anything for this user ID.\"\n);\nconst missingRoomInfoError = new Error(\n  \"resolveRoomsInfo didn't return anything for this room ID.\"\n);\n\nexport function createSharedContext<\n  TUserMeta extends BaseUserMeta = BaseUserMeta,\n>(client: Client): SharedContextBundle<TUserMeta> {\n  const usersStore = client[kInternal].usersStore;\n  const roomsInfoStore = client[kInternal].roomsInfoStore;\n\n  function useUser(userId: string): UserState<TUserMeta[\"info\"]> {\n    const getUserState = useCallback(\n      () => usersStore.getState(userId),\n      [userId]\n    );\n\n    useEffect(() => {\n      void usersStore.get(userId);\n    }, [userId]);\n\n    const state = useSyncExternalStore(\n      usersStore.subscribe,\n      getUserState,\n      getUserState\n    );\n\n    return state\n      ? ({\n          isLoading: state.isLoading,\n          user: state.data,\n          // Return an error if `undefined` was returned by `resolveUsers` for this user ID\n          error:\n            !state.isLoading && !state.data && !state.error\n              ? missingUserError\n              : state.error,\n        } as UserState<TUserMeta[\"info\"]>)\n      : { isLoading: true };\n  }\n\n  function useUserSuspense(userId: string) {\n    const getUserState = useCallback(\n      () => usersStore.getState(userId),\n      [userId]\n    );\n    const userState = getUserState();\n\n    if (!userState || userState.isLoading) {\n      throw usersStore.get(userId);\n    }\n\n    if (userState.error) {\n      throw userState.error;\n    }\n\n    // Throw an error if `undefined` was returned by `resolveUsers` for this user ID\n    if (!userState.data) {\n      throw missingUserError;\n    }\n\n    const state = useSyncExternalStore(\n      usersStore.subscribe,\n      getUserState,\n      getUserState\n    );\n\n    return {\n      isLoading: false,\n      user: state?.data,\n      error: state?.error,\n    } as UserStateSuccess<TUserMeta[\"info\"]>;\n  }\n\n  function useRoomInfo(roomId: string): RoomInfoState {\n    const getRoomInfoState = useCallback(\n      () => roomsInfoStore.getState(roomId),\n      [roomId]\n    );\n\n    useEffect(() => {\n      void roomsInfoStore.get(roomId);\n    }, [roomId]);\n\n    const state = useSyncExternalStore(\n      roomsInfoStore.subscribe,\n      getRoomInfoState,\n      getRoomInfoState\n    );\n\n    return state\n      ? ({\n          isLoading: state.isLoading,\n          info: state.data,\n          // Return an error if `undefined` was returned by `resolveRoomsInfo` for this room ID\n          error:\n            !state.isLoading && !state.data && !state.error\n              ? missingRoomInfoError\n              : state.error,\n        } as RoomInfoState)\n      : { isLoading: true };\n  }\n\n  function useRoomInfoSuspense(roomId: string) {\n    const getRoomInfoState = useCallback(\n      () => roomsInfoStore.getState(roomId),\n      [roomId]\n    );\n    const roomInfoState = getRoomInfoState();\n\n    if (!roomInfoState || roomInfoState.isLoading) {\n      throw roomsInfoStore.get(roomId);\n    }\n\n    if (roomInfoState.error) {\n      throw roomInfoState.error;\n    }\n\n    // Throw an error if `undefined` was returned by `resolveRoomsInfo` for this room ID\n    if (!roomInfoState.data) {\n      throw missingRoomInfoError;\n    }\n\n    const state = useSyncExternalStore(\n      roomsInfoStore.subscribe,\n      getRoomInfoState,\n      getRoomInfoState\n    );\n\n    return {\n      isLoading: false,\n      info: state?.data,\n      error: state?.error,\n    } as RoomInfoStateSuccess;\n  }\n\n  const bundle: SharedContextBundle<TUserMeta> = {\n    useUser,\n    useRoomInfo,\n\n    suspense: {\n      useUser: useUserSuspense,\n      useRoomInfo: useRoomInfoSuspense,\n    },\n  };\n\n  return bundle;\n}\n","import type {\n  BaseUserMeta,\n  BroadcastOptions,\n  Client,\n  History,\n  Json,\n  JsonObject,\n  LiveObject,\n  LostConnectionEvent,\n  LsonObject,\n  OthersEvent,\n  Room,\n  Status,\n  User,\n} from \"@liveblocks/client\";\nimport { shallow } from \"@liveblocks/client\";\nimport type {\n  BaseMetadata,\n  CacheState,\n  CacheStore,\n  CommentData,\n  CommentsEventServerMsg,\n  EnterOptions,\n  LiveblocksError,\n  OptionalPromise,\n  ResolveMentionSuggestionsArgs,\n  ResolveUsersArgs,\n  RoomEventMessage,\n  RoomNotificationSettings,\n  ThreadData,\n  ToImmutable,\n} from \"@liveblocks/core\";\nimport {\n  addReaction,\n  CommentsApiError,\n  console,\n  deleteComment,\n  deprecateIf,\n  errorIf,\n  isLiveNode,\n  kInternal,\n  makeEventSource,\n  makePoller,\n  NotificationsApiError,\n  removeReaction,\n  ServerMsgCode,\n  stringify,\n  upsertComment,\n} from \"@liveblocks/core\";\nimport { nanoid } from \"nanoid\";\nimport * as React from \"react\";\nimport { useSyncExternalStoreWithSelector } from \"use-sync-external-store/shim/with-selector.js\";\n\nimport {\n  AddReactionError,\n  type CommentsError,\n  CreateCommentError,\n  CreateThreadError,\n  DeleteCommentError,\n  EditCommentError,\n  EditThreadMetadataError,\n  MarkInboxNotificationAsReadError,\n  RemoveReactionError,\n  UpdateNotificationSettingsError,\n} from \"./comments/errors\";\nimport { createCommentId, createThreadId } from \"./comments/lib/createIds\";\nimport { selectNotificationSettings } from \"./comments/lib/select-notification-settings\";\nimport { selectedInboxNotifications } from \"./comments/lib/selected-inbox-notifications\";\nimport { selectedThreads } from \"./comments/lib/selected-threads\";\nimport { retryError } from \"./lib/retry-error\";\nimport { useInitial } from \"./lib/use-initial\";\nimport { useLatest } from \"./lib/use-latest\";\nimport { useRerender } from \"./lib/use-rerender\";\nimport { createSharedContext } from \"./shared\";\nimport type {\n  CommentReactionOptions,\n  CreateCommentOptions,\n  CreateThreadOptions,\n  DeleteCommentOptions,\n  EditCommentOptions,\n  EditThreadMetadataOptions,\n  MutationContext,\n  OmitFirstArg,\n  RoomContextBundle,\n  RoomNotificationSettingsState,\n  RoomNotificationSettingsStateSuccess,\n  RoomProviderProps,\n  ThreadsState,\n  ThreadsStateResolved,\n  ThreadsStateSuccess,\n  ThreadSubscription,\n  UseThreadsOptions,\n} from \"./types\";\n\nconst noop = () => {};\nconst identity: <T>(x: T) => T = (x) => x;\n\nconst missing_unstable_batchedUpdates = (\n  reactVersion: number,\n  roomId: string\n) =>\n  `We noticed you’re using React ${reactVersion}. Please pass unstable_batchedUpdates at the RoomProvider level until you’re ready to upgrade to React 18:\n\n    import { unstable_batchedUpdates } from \"react-dom\";  // or \"react-native\"\n\n    <RoomProvider id=${JSON.stringify(\n      roomId\n    )} ... unstable_batchedUpdates={unstable_batchedUpdates}>\n      ...\n    </RoomProvider>\n\nWhy? Please see https://liveblocks.io/docs/platform/troubleshooting#stale-props-zombie-child for more information`;\n\nconst superfluous_unstable_batchedUpdates =\n  \"You don’t need to pass unstable_batchedUpdates to RoomProvider anymore, since you’re on React 18+ already.\";\n\nfunction useSyncExternalStore<Snapshot>(\n  s: (onStoreChange: () => void) => () => void,\n  gs: () => Snapshot,\n  gss: undefined | null | (() => Snapshot)\n): Snapshot {\n  return useSyncExternalStoreWithSelector(s, gs, gss, identity);\n}\n\nconst STABLE_EMPTY_LIST = Object.freeze([]);\n\nexport const POLLING_INTERVAL = 5 * 60 * 1000; // 5 minutes\n\nconst MENTION_SUGGESTIONS_DEBOUNCE = 500;\n\n// Don't try to inline this. This function is intended to be a stable\n// reference, to avoid a React.useCallback() wrapper.\nfunction alwaysEmptyList() {\n  return STABLE_EMPTY_LIST;\n}\n\n// Don't try to inline this. This function is intended to be a stable\n// reference, to avoid a React.useCallback() wrapper.\nfunction alwaysNull() {\n  return null;\n}\n\nfunction makeMutationContext<\n  TPresence extends JsonObject,\n  TStorage extends LsonObject,\n  TUserMeta extends BaseUserMeta,\n  TRoomEvent extends Json,\n>(\n  room: Room<TPresence, TStorage, TUserMeta, TRoomEvent>\n): MutationContext<TPresence, TStorage, TUserMeta> {\n  const errmsg =\n    \"This mutation cannot be used until connected to the Liveblocks room\";\n\n  return {\n    get storage() {\n      const mutableRoot = room.getStorageSnapshot();\n      if (mutableRoot === null) {\n        throw new Error(errmsg);\n      }\n      return mutableRoot;\n    },\n\n    get self() {\n      const self = room.getSelf();\n      if (self === null) {\n        throw new Error(errmsg);\n      }\n      return self;\n    },\n\n    get others() {\n      const others = room.getOthers();\n      if (room.getSelf() === null) {\n        throw new Error(errmsg);\n      }\n      return others;\n    },\n\n    setMyPresence: room.updatePresence,\n  };\n}\n\nexport const ContextBundle = React.createContext<RoomContextBundle<\n  JsonObject,\n  LsonObject,\n  BaseUserMeta,\n  never,\n  BaseMetadata\n> | null>(null);\n\n/**\n * @private\n *\n * This is an internal API, use `createRoomContext` instead.\n */\nexport function useRoomContextBundle() {\n  const bundle = React.useContext(ContextBundle);\n  if (bundle === null) {\n    throw new Error(\"RoomProvider is missing from the React tree.\");\n  }\n  return bundle;\n}\n\ntype Options<TUserMeta extends BaseUserMeta> = {\n  /**\n   * @deprecated Define 'resolveUsers' in 'createClient' from '@liveblocks/client' instead.\n   * Please refer to our Upgrade Guide to learn more, see https://liveblocks.io/docs/platform/upgrading/1.10.\n   *\n   * A function that returns user info from user IDs.\n   */\n  resolveUsers?: (\n    args: ResolveUsersArgs\n  ) => OptionalPromise<(TUserMeta[\"info\"] | undefined)[] | undefined>;\n\n  /**\n   * @deprecated Define 'resolveMentionSuggestions' in 'createClient' from '@liveblocks/client' instead.\n   * Please refer to our Upgrade Guide to learn more, see https://liveblocks.io/docs/platform/upgrading/1.10.\n   *\n   * A function that returns a list of user IDs matching a string.\n   */\n  resolveMentionSuggestions?: (\n    args: ResolveMentionSuggestionsArgs\n  ) => OptionalPromise<string[]>;\n};\n\nexport function createRoomContext<\n  TPresence extends JsonObject,\n  TStorage extends LsonObject = LsonObject,\n  TUserMeta extends BaseUserMeta = BaseUserMeta,\n  TRoomEvent extends Json = never,\n  TThreadMetadata extends BaseMetadata = never,\n>(\n  client: Client,\n  options?: Options<TUserMeta>\n): RoomContextBundle<\n  TPresence,\n  TStorage,\n  TUserMeta,\n  TRoomEvent,\n  TThreadMetadata\n> {\n  type TRoom = Room<TPresence, TStorage, TUserMeta, TRoomEvent>;\n  type TRoomLeavePair = { room: TRoom; leave: () => void };\n\n  // Deprecated option\n  if (options?.resolveUsers) {\n    throw new Error(\n      \"The 'resolveUsers' option has moved to 'createClient' from '@liveblocks/client'. Please refer to our Upgrade Guide to learn more, see https://liveblocks.io/docs/platform/upgrading/1.10.\"\n    );\n  }\n\n  // Deprecated option\n  if (options?.resolveMentionSuggestions) {\n    throw new Error(\n      \"The 'resolveMentionSuggestions' option has moved to 'createClient' from '@liveblocks/client'. Please refer to our Upgrade Guide to learn more, see https://liveblocks.io/docs/platform/upgrading/1.10.\"\n    );\n  }\n\n  const RoomContext = React.createContext<TRoom | null>(null);\n\n  const commentsErrorEventSource =\n    makeEventSource<CommentsError<TThreadMetadata>>();\n\n  const shared = createSharedContext<TUserMeta>(client);\n\n  /**\n   * RATIONALE:\n   * At the \"Outer\" RoomProvider level, we keep a cache and produce\n   * a stableEnterRoom function, which we pass down to the real \"Inner\"\n   * RoomProvider level.\n   *\n   * The purpose is to ensure that if `stableEnterRoom(\"my-room\")` is called\n   * multiple times for the same room ID, it will always return the exact same\n   * (cached) value, so that in total only a single \"leave\" function gets\n   * produced and registered in the client.\n   *\n   * If we didn't use this cache, then in React StrictMode\n   * stableEnterRoom(\"my-room\") might get called multiple (at least 4) times,\n   * causing more leave functions to be produced in the client, some of which\n   * we cannot get a hold on (because StrictMode would discard those results by\n   * design). This would make it appear to the Client that the Room is still in\n   * use by some party that hasn't called `leave()` on it yet, thus causing the\n   * Room to not be freed and destroyed when the component unmounts later.\n   */\n  function RoomProviderOuter(props: RoomProviderProps<TPresence, TStorage>) {\n    const [cache] = React.useState<Map<string, TRoomLeavePair>>(\n      () => new Map()\n    );\n\n    // Produce a version of client.enterRoom() that when called for the same\n    // room ID multiple times, will not keep producing multiple leave\n    // functions, but instead return the cached one.\n    const stableEnterRoom = React.useCallback(\n      (\n        roomId: string,\n        options: EnterOptions<TPresence, TStorage>\n      ): TRoomLeavePair => {\n        const cached = cache.get(roomId);\n        if (cached) return cached;\n\n        const rv = client.enterRoom<TPresence, TStorage, TUserMeta, TRoomEvent>(\n          roomId,\n          options\n        );\n\n        // Wrap the leave function to also delete the cached value\n        const origLeave = rv.leave;\n        rv.leave = () => {\n          origLeave();\n          cache.delete(roomId);\n        };\n\n        cache.set(roomId, rv);\n        return rv;\n      },\n      [cache]\n    );\n\n    return <RoomProviderInner {...props} stableEnterRoom={stableEnterRoom} />;\n  }\n\n  function RoomProviderInner(\n    props: RoomProviderProps<TPresence, TStorage> & {\n      stableEnterRoom: (\n        roomId: string,\n        options: EnterOptions<TPresence, TStorage>\n      ) => TRoomLeavePair;\n    }\n  ) {\n    const { id: roomId, stableEnterRoom } = props;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!roomId) {\n        throw new Error(\n          \"RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required\"\n        );\n      }\n\n      if (typeof roomId !== \"string\") {\n        throw new Error(\"RoomProvider id property should be a string.\");\n      }\n\n      const majorReactVersion = parseInt(React.version) || 1;\n      const oldReactVersion = majorReactVersion < 18;\n      errorIf(\n        oldReactVersion && props.unstable_batchedUpdates === undefined,\n        missing_unstable_batchedUpdates(majorReactVersion, roomId)\n      );\n      deprecateIf(\n        !oldReactVersion && props.unstable_batchedUpdates !== undefined,\n        superfluous_unstable_batchedUpdates\n      );\n    }\n\n    // Note: We'll hold on to the initial value given here, and ignore any\n    // changes to this argument in subsequent renders\n    const frozenProps = useInitial({\n      initialPresence: props.initialPresence,\n      initialStorage: props.initialStorage,\n      unstable_batchedUpdates: props.unstable_batchedUpdates,\n      autoConnect:\n        props.autoConnect ??\n        props.shouldInitiallyConnect ??\n        typeof window !== \"undefined\",\n    });\n\n    const [{ room }, setRoomLeavePair] = React.useState(() =>\n      stableEnterRoom(roomId, {\n        ...frozenProps,\n        autoConnect: false, // Deliberately using false here on the first render, see below\n      })\n    );\n\n    React.useEffect(() => {\n      async function handleCommentEvent(message: CommentsEventServerMsg) {\n        // TODO: Error handling\n        const info = await room[kInternal].comments.getThread({\n          threadId: message.threadId,\n        });\n\n        // If no thread info was returned (i.e., 404), we remove the thread and relevant inbox notifications from local cache.\n        if (!info) {\n          store.deleteThread(message.threadId);\n          return;\n        }\n        const { thread, inboxNotification } = info;\n\n        const existingThread = store.get().threads[message.threadId];\n\n        switch (message.type) {\n          case ServerMsgCode.COMMENT_EDITED:\n          case ServerMsgCode.THREAD_METADATA_UPDATED:\n          case ServerMsgCode.COMMENT_REACTION_ADDED:\n          case ServerMsgCode.COMMENT_REACTION_REMOVED:\n          case ServerMsgCode.COMMENT_DELETED:\n            // If the thread doesn't exist in the local cache, we do not update it with the server data as an optimistic update could have deleted the thread locally.\n            if (!existingThread) break;\n\n            store.updateThreadAndNotification(thread, inboxNotification);\n            break;\n          case ServerMsgCode.COMMENT_CREATED:\n            store.updateThreadAndNotification(thread, inboxNotification);\n            break;\n          default:\n            break;\n        }\n      }\n\n      return room.events.comments.subscribe(\n        (message) => void handleCommentEvent(message)\n      );\n    }, [room]);\n\n    React.useEffect(() => {\n      // Retrieve threads that have been updated/deleted since the last time the room requested threads updates\n      void getThreadsUpdates(room.id);\n    }, [room.id]);\n\n    /**\n     * Subscribe to the 'online' event to fetch threads/notifications updates when the browser goes back online.\n     */\n    React.useEffect(() => {\n      function handleIsOnline() {\n        void getThreadsUpdates(room.id);\n      }\n\n      window.addEventListener(\"online\", handleIsOnline);\n      return () => {\n        window.removeEventListener(\"online\", handleIsOnline);\n      };\n    }, [room.id]);\n\n    React.useEffect(() => {\n      const pair = stableEnterRoom(roomId, frozenProps);\n\n      setRoomLeavePair(pair);\n      const { room, leave } = pair;\n\n      // In React, it's important to start connecting to the room as an effect,\n      // rather than doing this during the initial render. This means that\n      // during the initial render (both on the server-side, and on the first\n      // hydration on the client-side), the value of the `useStatus()` hook\n      // will correctly be \"initial\", and transition to \"connecting\" as an\n      // effect.\n      if (frozenProps.autoConnect) {\n        room.connect();\n      }\n\n      return () => {\n        leave();\n      };\n    }, [roomId, frozenProps, stableEnterRoom]);\n\n    return (\n      <RoomContext.Provider value={room}>\n        <ContextBundle.Provider\n          value={\n            bundle as unknown as RoomContextBundle<\n              JsonObject,\n              LsonObject,\n              BaseUserMeta,\n              never,\n              BaseMetadata\n            >\n          }\n        >\n          {props.children}\n        </ContextBundle.Provider>\n      </RoomContext.Provider>\n    );\n  }\n\n  function connectionIdSelector(\n    others: readonly User<TPresence, TUserMeta>[]\n  ): number[] {\n    return others.map((user) => user.connectionId);\n  }\n\n  function useRoom(): TRoom {\n    const room = React.useContext(RoomContext);\n    if (room === null) {\n      throw new Error(\"RoomProvider is missing from the React tree.\");\n    }\n    return room;\n  }\n\n  function useStatus(): Status {\n    const room = useRoom();\n    const subscribe = room.events.status.subscribe;\n    const getSnapshot = room.getStatus;\n    const getServerSnapshot = room.getStatus;\n    return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n  }\n\n  function useMyPresence(): [\n    TPresence,\n    (patch: Partial<TPresence>, options?: { addToHistory: boolean }) => void,\n  ] {\n    const room = useRoom();\n    const subscribe = room.events.myPresence.subscribe;\n    const getSnapshot = room.getPresence;\n    const presence = useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n    const setPresence = room.updatePresence;\n    return [presence, setPresence];\n  }\n\n  function useUpdateMyPresence(): (\n    patch: Partial<TPresence>,\n    options?: { addToHistory: boolean }\n  ) => void {\n    return useRoom().updatePresence;\n  }\n\n  function useOthers(): readonly User<TPresence, TUserMeta>[];\n  function useOthers<T>(\n    selector: (others: readonly User<TPresence, TUserMeta>[]) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T;\n  function useOthers<T>(\n    selector?: (others: readonly User<TPresence, TUserMeta>[]) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T | readonly User<TPresence, TUserMeta>[] {\n    const room = useRoom();\n    const subscribe = room.events.others.subscribe;\n    const getSnapshot = room.getOthers;\n    const getServerSnapshot = alwaysEmptyList;\n    return useSyncExternalStoreWithSelector(\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      selector ??\n        (identity as (others: readonly User<TPresence, TUserMeta>[]) => T),\n      isEqual\n    );\n  }\n\n  function useOthersConnectionIds(): readonly number[] {\n    return useOthers(connectionIdSelector, shallow);\n  }\n\n  function useOthersMapped<T>(\n    itemSelector: (other: User<TPresence, TUserMeta>) => T,\n    itemIsEqual?: (prev: T, curr: T) => boolean\n  ): ReadonlyArray<readonly [connectionId: number, data: T]> {\n    const wrappedSelector = React.useCallback(\n      (others: readonly User<TPresence, TUserMeta>[]) =>\n        others.map(\n          (other) => [other.connectionId, itemSelector(other)] as const\n        ),\n      [itemSelector]\n    );\n\n    const wrappedIsEqual = React.useCallback(\n      (\n        a: ReadonlyArray<readonly [connectionId: number, data: T]>,\n        b: ReadonlyArray<readonly [connectionId: number, data: T]>\n      ): boolean => {\n        const eq = itemIsEqual ?? Object.is;\n        return (\n          a.length === b.length &&\n          a.every((atuple, index) => {\n            // We know btuple always exist because we checked the array length on the previous line\n            const btuple = b[index];\n            return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);\n          })\n        );\n      },\n      [itemIsEqual]\n    );\n\n    return useOthers(wrappedSelector, wrappedIsEqual);\n  }\n\n  const NOT_FOUND = Symbol();\n\n  type NotFound = typeof NOT_FOUND;\n\n  function useOther<T>(\n    connectionId: number,\n    selector: (other: User<TPresence, TUserMeta>) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T {\n    const wrappedSelector = React.useCallback(\n      (others: readonly User<TPresence, TUserMeta>[]) => {\n        // TODO: Make this O(1) instead of O(n)?\n        const other = others.find(\n          (other) => other.connectionId === connectionId\n        );\n        return other !== undefined ? selector(other) : NOT_FOUND;\n      },\n      [connectionId, selector]\n    );\n\n    const wrappedIsEqual = React.useCallback(\n      (prev: T | NotFound, curr: T | NotFound): boolean => {\n        if (prev === NOT_FOUND || curr === NOT_FOUND) {\n          return prev === curr;\n        }\n\n        const eq = isEqual ?? Object.is;\n        return eq(prev, curr);\n      },\n      [isEqual]\n    );\n\n    const other = useOthers(wrappedSelector, wrappedIsEqual);\n    if (other === NOT_FOUND) {\n      throw new Error(\n        `No such other user with connection id ${connectionId} exists`\n      );\n    }\n\n    return other;\n  }\n\n  function useBroadcastEvent(): (\n    event: TRoomEvent,\n    options?: BroadcastOptions\n  ) => void {\n    const room = useRoom();\n\n    return React.useCallback(\n      (\n        event: TRoomEvent,\n        options: BroadcastOptions = { shouldQueueEventIfNotReady: false }\n      ) => {\n        room.broadcastEvent(event, options);\n      },\n      [room]\n    );\n  }\n\n  function useOthersListener(\n    callback: (event: OthersEvent<TPresence, TUserMeta>) => void\n  ) {\n    const room = useRoom();\n    const savedCallback = useLatest(callback);\n\n    React.useEffect(\n      () =>\n        room.events.others.subscribe((event) => savedCallback.current(event)),\n      [room, savedCallback]\n    );\n  }\n\n  function useLostConnectionListener(\n    callback: (event: LostConnectionEvent) => void\n  ): void {\n    const room = useRoom();\n    const savedCallback = useLatest(callback);\n\n    React.useEffect(\n      () =>\n        room.events.lostConnection.subscribe((event) =>\n          savedCallback.current(event)\n        ),\n      [room, savedCallback]\n    );\n  }\n\n  function useErrorListener(callback: (err: LiveblocksError) => void): void {\n    const room = useRoom();\n    const savedCallback = useLatest(callback);\n\n    React.useEffect(\n      () => room.events.error.subscribe((e) => savedCallback.current(e)),\n      [room, savedCallback]\n    );\n  }\n\n  function useEventListener(\n    callback: (data: RoomEventMessage<TPresence, TUserMeta, TRoomEvent>) => void\n  ): void {\n    const room = useRoom();\n    const savedCallback = useLatest(callback);\n\n    React.useEffect(() => {\n      const listener = (\n        eventData: RoomEventMessage<TPresence, TUserMeta, TRoomEvent>\n      ) => {\n        savedCallback.current(eventData);\n      };\n\n      return room.events.customEvent.subscribe(listener);\n    }, [room, savedCallback]);\n  }\n\n  function useSelf(): User<TPresence, TUserMeta> | null;\n  function useSelf<T>(\n    selector: (me: User<TPresence, TUserMeta>) => T,\n    isEqual?: (prev: T | null, curr: T | null) => boolean\n  ): T | null;\n  function useSelf<T>(\n    maybeSelector?: (me: User<TPresence, TUserMeta>) => T,\n    isEqual?: (prev: T | null, curr: T | null) => boolean\n  ): T | User<TPresence, TUserMeta> | null {\n    type Snapshot = User<TPresence, TUserMeta> | null;\n    type Selection = T | null;\n\n    const room = useRoom();\n    const subscribe = room.events.self.subscribe;\n    const getSnapshot: () => Snapshot = room.getSelf;\n\n    const selector =\n      maybeSelector ?? (identity as (me: User<TPresence, TUserMeta>) => T);\n    const wrappedSelector = React.useCallback(\n      (me: Snapshot): Selection => (me !== null ? selector(me) : null),\n      [selector]\n    );\n\n    const getServerSnapshot = alwaysNull;\n\n    return useSyncExternalStoreWithSelector(\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      wrappedSelector,\n      isEqual\n    );\n  }\n\n  function useMutableStorageRoot(): LiveObject<TStorage> | null {\n    const room = useRoom();\n    const subscribe = room.events.storageDidLoad.subscribeOnce;\n    const getSnapshot = room.getStorageSnapshot;\n    const getServerSnapshot = alwaysNull;\n    return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n  }\n\n  // NOTE: This API exists for backward compatible reasons\n  function useStorageRoot(): [root: LiveObject<TStorage> | null] {\n    return [useMutableStorageRoot()];\n  }\n\n  function useHistory(): History {\n    return useRoom().history;\n  }\n\n  function useUndo(): () => void {\n    return useHistory().undo;\n  }\n\n  function useRedo(): () => void {\n    return useHistory().redo;\n  }\n\n  function useCanUndo(): boolean {\n    const room = useRoom();\n    const subscribe = room.events.history.subscribe;\n    const canUndo = room.history.canUndo;\n    return useSyncExternalStore(subscribe, canUndo, canUndo);\n  }\n\n  function useCanRedo(): boolean {\n    const room = useRoom();\n    const subscribe = room.events.history.subscribe;\n    const canRedo = room.history.canRedo;\n    return useSyncExternalStore(subscribe, canRedo, canRedo);\n  }\n\n  function useBatch<T>(): (callback: () => T) => T {\n    return useRoom().batch;\n  }\n\n  function useLegacyKey<TKey extends Extract<keyof TStorage, string>>(\n    key: TKey\n  ): TStorage[TKey] | null {\n    const room = useRoom();\n    const rootOrNull = useMutableStorageRoot();\n    const rerender = useRerender();\n\n    React.useEffect(() => {\n      if (rootOrNull === null) {\n        return;\n      }\n      const root = rootOrNull;\n\n      let unsubCurr: (() => void) | undefined;\n      let curr = root.get(key);\n\n      function subscribeToCurr() {\n        unsubCurr = isLiveNode(curr)\n          ? room.subscribe(curr, rerender)\n          : undefined;\n      }\n\n      function onRootChange() {\n        const newValue = root.get(key);\n        if (newValue !== curr) {\n          unsubCurr?.();\n          curr = newValue;\n          subscribeToCurr();\n          rerender();\n        }\n      }\n\n      subscribeToCurr();\n      rerender();\n\n      const unsubscribeRoot = room.subscribe(root, onRootChange);\n      return () => {\n        unsubscribeRoot();\n        unsubCurr?.();\n      };\n    }, [rootOrNull, room, key, rerender]);\n\n    if (rootOrNull === null) {\n      return null;\n    } else {\n      return rootOrNull.get(key);\n    }\n  }\n\n  function useStorage<T>(\n    selector: (root: ToImmutable<TStorage>) => T,\n    isEqual?: (prev: T | null, curr: T | null) => boolean\n  ): T | null {\n    type Snapshot = ToImmutable<TStorage> | null;\n    type Selection = T | null;\n\n    const room = useRoom();\n    const rootOrNull = useMutableStorageRoot();\n\n    const wrappedSelector = React.useCallback(\n      (rootOrNull: Snapshot): Selection =>\n        rootOrNull !== null ? selector(rootOrNull) : null,\n      [selector]\n    );\n\n    const subscribe = React.useCallback(\n      (onStoreChange: () => void) =>\n        rootOrNull !== null\n          ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true })\n          : noop,\n      [room, rootOrNull]\n    );\n\n    const getSnapshot = React.useCallback((): Snapshot => {\n      if (rootOrNull === null) {\n        return null;\n      } else {\n        const root = rootOrNull;\n        const imm = root.toImmutable();\n        return imm;\n      }\n    }, [rootOrNull]);\n\n    const getServerSnapshot = alwaysNull;\n\n    return useSyncExternalStoreWithSelector(\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      wrappedSelector,\n      isEqual\n    );\n  }\n\n  function ensureNotServerSide(): void {\n    // Error early if suspense is used in a server-side context\n    if (typeof window === \"undefined\") {\n      throw new Error(\n        \"You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.\\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr\"\n      );\n    }\n  }\n\n  function useSuspendUntilStorageLoaded(): void {\n    const room = useRoom();\n    if (room.getStorageSnapshot() !== null) {\n      return;\n    }\n\n    ensureNotServerSide();\n\n    // Throw a _promise_. Suspense will suspend the component tree until this\n    // promise resolves (aka until storage has loaded). After that, it will\n    // render this component tree again.\n    throw new Promise<void>((res) => {\n      room.events.storageDidLoad.subscribeOnce(() => res());\n    });\n  }\n\n  function useSuspendUntilPresenceLoaded(): void {\n    const room = useRoom();\n    if (room.getSelf() !== null) {\n      return;\n    }\n\n    ensureNotServerSide();\n\n    // Throw a _promise_. Suspense will suspend the component tree until either\n    // until either a presence update event, or a connection status change has\n    // happened. After that, it will render this component tree again and\n    // re-evaluate the .getSelf() condition above, or re-suspend again until\n    // such event happens.\n    throw new Promise<void>((res) => {\n      room.events.self.subscribeOnce(() => res());\n      room.events.status.subscribeOnce(() => res());\n    });\n  }\n\n  function useMutation<\n    F extends (\n      context: MutationContext<TPresence, TStorage, TUserMeta>,\n      ...args: any[]\n    ) => any,\n  >(callback: F, deps: readonly unknown[]): OmitFirstArg<F> {\n    const room = useRoom();\n    return React.useMemo(\n      () => {\n        return ((...args) =>\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n          room.batch(() =>\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            callback(\n              makeMutationContext(room),\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n              ...args\n            )\n          )) as OmitFirstArg<F>;\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [room, ...deps]\n    );\n  }\n\n  function useStorageSuspense<T>(\n    selector: (root: ToImmutable<TStorage>) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T {\n    useSuspendUntilStorageLoaded();\n    return useStorage(\n      selector,\n      isEqual as (prev: T | null, curr: T | null) => boolean\n    ) as T;\n  }\n\n  function useSelfSuspense(): User<TPresence, TUserMeta>;\n  function useSelfSuspense<T>(\n    selector: (me: User<TPresence, TUserMeta>) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T;\n  function useSelfSuspense<T>(\n    selector?: (me: User<TPresence, TUserMeta>) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T | User<TPresence, TUserMeta> {\n    useSuspendUntilPresenceLoaded();\n    return useSelf(\n      selector as (me: User<TPresence, TUserMeta>) => T,\n      isEqual as (prev: T | null, curr: T | null) => boolean\n    ) as T | User<TPresence, TUserMeta>;\n  }\n\n  function useOthersSuspense<T>(\n    selector?: (others: readonly User<TPresence, TUserMeta>[]) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T | readonly User<TPresence, TUserMeta>[] {\n    useSuspendUntilPresenceLoaded();\n    return useOthers(\n      selector as (others: readonly User<TPresence, TUserMeta>[]) => T,\n      isEqual as (prev: T, curr: T) => boolean\n    ) as T | readonly User<TPresence, TUserMeta>[];\n  }\n\n  function useOthersConnectionIdsSuspense(): readonly number[] {\n    useSuspendUntilPresenceLoaded();\n    return useOthersConnectionIds();\n  }\n\n  function useOthersMappedSuspense<T>(\n    itemSelector: (other: User<TPresence, TUserMeta>) => T,\n    itemIsEqual?: (prev: T, curr: T) => boolean\n  ): ReadonlyArray<readonly [connectionId: number, data: T]> {\n    useSuspendUntilPresenceLoaded();\n    return useOthersMapped(itemSelector, itemIsEqual);\n  }\n\n  function useOtherSuspense<T>(\n    connectionId: number,\n    selector: (other: User<TPresence, TUserMeta>) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T {\n    useSuspendUntilPresenceLoaded();\n    return useOther(connectionId, selector, isEqual);\n  }\n\n  function useLegacyKeySuspense<TKey extends Extract<keyof TStorage, string>>(\n    key: TKey\n  ): TStorage[TKey] {\n    useSuspendUntilStorageLoaded();\n    return useLegacyKey(key) as TStorage[TKey];\n  }\n\n  const store = client[kInternal]\n    .cacheStore as unknown as CacheStore<TThreadMetadata>;\n\n  function onMutationFailure(\n    innerError: Error,\n    optimisticUpdateId: string,\n    createPublicError: (error: Error) => CommentsError<TThreadMetadata>\n  ) {\n    store.set((state) => ({\n      ...state,\n      optimisticUpdates: state.optimisticUpdates.filter(\n        (update) => update.id !== optimisticUpdateId\n      ),\n    }));\n\n    if (innerError instanceof CommentsApiError) {\n      const error = handleApiError(innerError);\n      commentsErrorEventSource.notify(createPublicError(error));\n      return;\n    }\n\n    if (innerError instanceof NotificationsApiError) {\n      handleApiError(innerError);\n      // TODO: Create public error and notify via notificationsErrorEventSource?\n      return;\n    }\n\n    throw innerError;\n  }\n\n  const subscribersByQuery: Map<string, number> = new Map(); // A map of query keys to the number of subscribers for that query\n  const requestsByQuery: Map<string, Promise<any>> = new Map(); // A map of query keys to the promise of the request for that query\n\n  const poller = makePoller(refreshThreadsAndNotifications);\n\n  async function refreshThreadsAndNotifications() {\n    const requests: Promise<any>[] = [];\n\n    client[kInternal].getRoomIds().map((roomId) => {\n      const room = client.getRoom(roomId);\n      if (room === null) return;\n\n      // Retrieve threads that have been updated/deleted since the last requestedAt value\n      requests.push(getThreadsUpdates(room.id));\n    });\n\n    await Promise.allSettled(requests);\n  }\n\n  function incrementQuerySubscribers(queryKey: string) {\n    const subscribers = subscribersByQuery.get(queryKey) ?? 0;\n    subscribersByQuery.set(queryKey, subscribers + 1);\n\n    poller.start(POLLING_INTERVAL);\n  }\n\n  function decrementQuerySubscribers(queryKey: string) {\n    const subscribers = subscribersByQuery.get(queryKey);\n\n    if (subscribers === undefined || subscribers <= 0) {\n      console.warn(\n        `Internal unexpected behavior. Cannot decrease subscriber count for query \"${queryKey}\"`\n      );\n      return;\n    }\n\n    subscribersByQuery.set(queryKey, subscribers - 1);\n\n    let totalSubscribers = 0;\n    for (const subscribers of subscribersByQuery.values()) {\n      totalSubscribers += subscribers;\n    }\n\n    if (totalSubscribers <= 0) {\n      poller.stop();\n    }\n  }\n\n  async function getThreadsAndInboxNotifications(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>,\n    queryKey: string,\n    options: UseThreadsOptions<TThreadMetadata>,\n    { retryCount }: { retryCount: number } = { retryCount: 0 }\n  ) {\n    const existingRequest = requestsByQuery.get(queryKey);\n\n    // If a request was already made for the query, we do not make another request and return the existing promise of the request\n    if (existingRequest !== undefined) return existingRequest;\n\n    const request = room[kInternal].comments.getThreads(options);\n\n    // Store the promise of the request for the query so that we do not make another request for the same query\n    requestsByQuery.set(queryKey, request);\n\n    store.setQueryState(queryKey, {\n      isLoading: true,\n    });\n\n    try {\n      const result = await request;\n\n      store.updateThreadsAndNotifications(\n        result.threads,\n        result.inboxNotifications,\n        result.deletedThreads,\n        result.deletedInboxNotifications,\n        queryKey\n      );\n\n      const lastRequestedAt = lastRequestedAtByRoom.get(room.id);\n\n      /**\n       * We set the `lastRequestedAt` value for the room to the timestamp returned by the current request if:\n       * 1. The `lastRequestedAt` value for the room has not been set\n       * OR\n       * 2. The `lastRequestedAt` value for the room is older than the timestamp returned by the current request\n       */\n      if (\n        lastRequestedAt === undefined ||\n        lastRequestedAt > result.meta.requestedAt\n      ) {\n        lastRequestedAtByRoom.set(room.id, result.meta.requestedAt);\n      }\n\n      poller.start(POLLING_INTERVAL);\n    } catch (err) {\n      requestsByQuery.delete(queryKey);\n\n      // Retry the action using the exponential backoff algorithm\n      retryError(() => {\n        void getThreadsAndInboxNotifications(room, queryKey, options, {\n          retryCount: retryCount + 1,\n        });\n      }, retryCount);\n\n      // Set the query state to the error state\n      store.setQueryState(queryKey, {\n        isLoading: false,\n        error: err as Error,\n      });\n\n      return;\n    }\n  }\n\n  const DEFAULT_DEDUPING_INTERVAL = 2000; // 2 seconds\n\n  const lastRequestedAtByRoom = new Map<string, Date>(); // A map of room ids to the timestamp when the last request for threads updates was made\n  const requestStatusByRoom = new Map<string, boolean>(); // A map of room ids to a boolean indicating whether a request to retrieve threads updates is in progress\n\n  /**\n   * Retrieve threads that have been updated/deleted since the last time the room requested threads updates and update the local cache with the new data\n   * @param roomId The id of the room for which to retrieve threads updates\n   */\n  async function getThreadsUpdates(roomId: string) {\n    const room = client.getRoom(roomId);\n    if (room === null) return;\n\n    const since = lastRequestedAtByRoom.get(room.id);\n    if (since === undefined) return;\n\n    const isFetchingThreadsUpdates = requestStatusByRoom.get(room.id) ?? false;\n    // If another request to retrieve threads updates for the room is in progress, we do not start a new one\n    if (isFetchingThreadsUpdates === true) return;\n\n    try {\n      // Set the isFetchingThreadsUpdates flag to true to prevent multiple requests to fetch threads updates for the room from being made at the same time\n      requestStatusByRoom.set(room.id, true);\n      const updates = await room[kInternal].comments.getThreads({ since });\n\n      // Set the isFetchingThreadsUpdates flag to false after a certain interval to prevent multiple requests from being made at the same time\n      setTimeout(() => {\n        requestStatusByRoom.set(room.id, false);\n      }, DEFAULT_DEDUPING_INTERVAL);\n\n      store.updateThreadsAndNotifications(\n        updates.threads,\n        updates.inboxNotifications,\n        updates.deletedThreads,\n        updates.deletedInboxNotifications\n      );\n\n      // Update the `lastRequestedAt` value for the room to the timestamp returned by the current request\n      lastRequestedAtByRoom.set(room.id, updates.meta.requestedAt);\n    } catch (err) {\n      requestStatusByRoom.set(room.id, false);\n      // TODO: Implement error handling\n      return;\n    }\n  }\n\n  /**\n   * Scroll to the comment with the ID in the hash of the URL based on whether\n   * the query is loading and whether the hook should scroll to the comment on load.\n   */\n  function handleScrollToCommentOnLoad(\n    isQueryLoading: boolean,\n    shouldScrollOnLoad: boolean,\n    state: ThreadsStateResolved<TThreadMetadata>\n  ) {\n    if (shouldScrollOnLoad === false) return;\n\n    if (isQueryLoading === true) return;\n\n    const isWindowDefined = typeof window !== \"undefined\";\n    if (!isWindowDefined) return;\n\n    const hash = window.location.hash;\n    const commentId = hash.slice(1);\n\n    // If the hash is not a comment ID, we do not scroll to it\n    if (!commentId.startsWith(\"cm_\")) return;\n\n    // If a comment with the ID does not exist in the DOM, we do not scroll to it\n    const comment = document.getElementById(commentId);\n    if (comment === null) return;\n\n    const comments = state.threads.flatMap((thread) => thread.comments);\n    const isCommentInThreads = comments.some(\n      (comment) => comment.id === commentId\n    );\n\n    // If the comment is not in the threads for this hook, we do not scroll to it\n    if (!isCommentInThreads) return;\n\n    comment.scrollIntoView();\n  }\n\n  function useThreads(\n    options: UseThreadsOptions<TThreadMetadata> = {\n      query: { metadata: {} },\n    }\n  ): ThreadsState<TThreadMetadata> {\n    const { scrollOnLoad = true } = options;\n    const room = useRoom();\n    const queryKey = React.useMemo(\n      () => generateQueryKey(room.id, options.query),\n      [room, options]\n    );\n\n    React.useEffect(() => {\n      void getThreadsAndInboxNotifications(room, queryKey, options);\n      incrementQuerySubscribers(queryKey);\n\n      return () => decrementQuerySubscribers(queryKey);\n    }, [room, queryKey]); // eslint-disable-line react-hooks/exhaustive-deps\n\n    const selector = React.useCallback(\n      (state: CacheState<TThreadMetadata>): ThreadsState<TThreadMetadata> => {\n        const query = state.queries[queryKey];\n        if (query === undefined || query.isLoading) {\n          return {\n            isLoading: true,\n          };\n        }\n\n        return {\n          threads: selectedThreads(room.id, state, options),\n          isLoading: false,\n          error: query.error,\n        };\n      },\n      [room, queryKey] // eslint-disable-line react-hooks/exhaustive-deps\n    );\n\n    const state = useSyncExternalStoreWithSelector(\n      store.subscribe,\n      store.get,\n      store.get,\n      selector\n    );\n\n    React.useEffect(\n      () => {\n        if (state.isLoading === true) return;\n\n        handleScrollToCommentOnLoad(state.isLoading, scrollOnLoad, state);\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once\n      [state.isLoading]\n    );\n\n    return state;\n  }\n\n  function useThreadsSuspense(\n    options: UseThreadsOptions<TThreadMetadata> = {\n      query: { metadata: {} },\n    }\n  ): ThreadsStateSuccess<TThreadMetadata> {\n    const { scrollOnLoad = true } = options;\n\n    const room = useRoom();\n    const queryKey = React.useMemo(\n      () => generateQueryKey(room.id, options.query),\n      [room, options]\n    );\n\n    const query = store.get().queries[queryKey];\n\n    if (query === undefined || query.isLoading) {\n      throw getThreadsAndInboxNotifications(room, queryKey, options);\n    }\n\n    if (query.error) {\n      throw query.error;\n    }\n\n    const selector = React.useCallback(\n      (\n        state: CacheState<TThreadMetadata>\n      ): ThreadsStateSuccess<TThreadMetadata> => {\n        return {\n          threads: selectedThreads(room.id, state, options),\n          isLoading: false,\n        };\n      },\n      [room, queryKey] // eslint-disable-line react-hooks/exhaustive-deps\n    );\n\n    React.useEffect(() => {\n      incrementQuerySubscribers(queryKey);\n\n      return () => {\n        decrementQuerySubscribers(queryKey);\n      };\n    }, [queryKey]);\n\n    const state = useSyncExternalStoreWithSelector(\n      store.subscribe,\n      store.get,\n      store.get,\n      selector\n    );\n\n    React.useEffect(\n      () => {\n        handleScrollToCommentOnLoad(state.isLoading, scrollOnLoad, state);\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once\n      [state.isLoading]\n    );\n\n    return state;\n  }\n\n  function useCreateThread() {\n    const room = useRoom();\n    return React.useCallback(\n      (\n        options: CreateThreadOptions<TThreadMetadata>\n      ): ThreadData<TThreadMetadata> => {\n        const body = options.body;\n        const metadata: TThreadMetadata =\n          \"metadata\" in options ? options.metadata : ({} as TThreadMetadata);\n\n        const threadId = createThreadId();\n        const commentId = createCommentId();\n        const createdAt = new Date();\n\n        const newComment: CommentData = {\n          id: commentId,\n          threadId,\n          roomId: room.id,\n          createdAt,\n          type: \"comment\",\n          userId: getCurrentUserId(room),\n          body,\n          reactions: [],\n        };\n        const newThread: ThreadData<TThreadMetadata> = {\n          id: threadId,\n          type: \"thread\",\n          createdAt,\n          updatedAt: createdAt,\n          roomId: room.id,\n          metadata: metadata as ThreadData<TThreadMetadata>[\"metadata\"],\n          comments: [newComment],\n        };\n\n        const optimisticUpdateId = nanoid();\n\n        store.pushOptimisticUpdate({\n          type: \"create-thread\",\n          thread: newThread,\n          id: optimisticUpdateId,\n        });\n\n        room[kInternal].comments\n          .createThread({ threadId, commentId, body, metadata })\n          .then(\n            (thread) => {\n              store.set((state) => ({\n                ...state,\n                threads: {\n                  ...state.threads,\n                  [threadId]: thread,\n                },\n                optimisticUpdates: state.optimisticUpdates.filter(\n                  (update) => update.id !== optimisticUpdateId\n                ),\n              }));\n            },\n            (err: Error) =>\n              onMutationFailure(\n                err,\n                optimisticUpdateId,\n                (err) =>\n                  new CreateThreadError(err, {\n                    roomId: room.id,\n                    threadId,\n                    commentId,\n                    body,\n                    metadata,\n                  })\n              )\n          );\n\n        return newThread;\n      },\n      [room]\n    );\n  }\n\n  function useEditThreadMetadata() {\n    const room = useRoom();\n    return React.useCallback(\n      (options: EditThreadMetadataOptions<TThreadMetadata>): void => {\n        if (!(\"metadata\" in options)) {\n          return;\n        }\n\n        const threadId = options.threadId;\n        const metadata = options.metadata;\n        const updatedAt = new Date();\n\n        const optimisticUpdateId = nanoid();\n\n        store.pushOptimisticUpdate({\n          type: \"edit-thread-metadata\",\n          metadata,\n          id: optimisticUpdateId,\n          threadId,\n          updatedAt,\n        });\n\n        room[kInternal].comments\n          .editThreadMetadata({ metadata, threadId })\n          .then(\n            (metadata) => {\n              store.set((state) => {\n                const existingThread = state.threads[threadId];\n                const updatedOptimisticUpdates = state.optimisticUpdates.filter(\n                  (update) => update.id !== optimisticUpdateId\n                );\n\n                // If the thread doesn't exist in the cache, we do not update the metadata\n                if (existingThread === undefined) {\n                  return {\n                    ...state,\n                    optimisticUpdates: updatedOptimisticUpdates,\n                  };\n                }\n\n                // If the thread has been deleted, we do not update the metadata\n                if (existingThread.deletedAt !== undefined) {\n                  return {\n                    ...state,\n                    optimisticUpdates: updatedOptimisticUpdates,\n                  };\n                }\n\n                if (\n                  existingThread.updatedAt &&\n                  existingThread.updatedAt > updatedAt\n                ) {\n                  return {\n                    ...state,\n                    optimisticUpdates: updatedOptimisticUpdates,\n                  };\n                }\n\n                return {\n                  ...state,\n                  threads: {\n                    ...state.threads,\n                    [threadId]: {\n                      ...existingThread,\n                      metadata: metadata as [TThreadMetadata] extends [never]\n                        ? Record<string, never>\n                        : TThreadMetadata,\n                    },\n                  },\n                  optimisticUpdates: updatedOptimisticUpdates,\n                };\n              });\n            },\n            (err: Error) =>\n              onMutationFailure(\n                err,\n                optimisticUpdateId,\n                (error) =>\n                  new EditThreadMetadataError(error, {\n                    roomId: room.id,\n                    threadId,\n                    metadata,\n                  })\n              )\n          );\n      },\n      [room]\n    );\n  }\n\n  function useAddReaction() {\n    const room = useRoom();\n    return React.useCallback(\n      ({ threadId, commentId, emoji }: CommentReactionOptions): void => {\n        const createdAt = new Date();\n        const userId = getCurrentUserId(room);\n\n        const optimisticUpdateId = nanoid();\n\n        store.pushOptimisticUpdate({\n          type: \"add-reaction\",\n          threadId,\n          commentId,\n          reaction: {\n            emoji,\n            userId,\n            createdAt,\n          },\n          id: optimisticUpdateId,\n        });\n\n        room[kInternal].comments\n          .addReaction({ threadId, commentId, emoji })\n          .then(\n            (addedReaction) => {\n              store.set((state): CacheState<TThreadMetadata> => {\n                const existingThread = state.threads[threadId];\n                const updatedOptimisticUpdates = state.optimisticUpdates.filter(\n                  (update) => update.id !== optimisticUpdateId\n                );\n\n                // If the thread doesn't exist in the cache, we do not update the metadata\n                if (existingThread === undefined) {\n                  return {\n                    ...state,\n                    optimisticUpdates: updatedOptimisticUpdates,\n                  };\n                }\n\n                return {\n                  ...state,\n                  threads: {\n                    ...state.threads,\n                    [threadId]: addReaction(\n                      existingThread,\n                      commentId,\n                      addedReaction\n                    ),\n                  },\n                  optimisticUpdates: updatedOptimisticUpdates,\n                };\n              });\n            },\n            (err: Error) =>\n              onMutationFailure(\n                err,\n                optimisticUpdateId,\n                (error) =>\n                  new AddReactionError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId,\n                    emoji,\n                  })\n              )\n          );\n      },\n      [room]\n    );\n  }\n\n  function useRemoveReaction() {\n    const room = useRoom();\n    return React.useCallback(\n      ({ threadId, commentId, emoji }: CommentReactionOptions): void => {\n        const userId = getCurrentUserId(room);\n\n        const removedAt = new Date();\n        const optimisticUpdateId = nanoid();\n\n        store.pushOptimisticUpdate({\n          type: \"remove-reaction\",\n          threadId,\n          commentId,\n          emoji,\n          userId,\n          removedAt,\n          id: optimisticUpdateId,\n        });\n\n        room[kInternal].comments\n          .removeReaction({ threadId, commentId, emoji })\n          .then(\n            () => {\n              store.set((state) => {\n                const existingThread = state.threads[threadId];\n                const updatedOptimisticUpdates = state.optimisticUpdates.filter(\n                  (update) => update.id !== optimisticUpdateId\n                );\n\n                // If the thread doesn't exist in the cache, we do not update the metadata\n                if (existingThread === undefined) {\n                  return {\n                    ...state,\n                    optimisticUpdates: updatedOptimisticUpdates,\n                  };\n                }\n\n                return {\n                  ...state,\n                  threads: {\n                    ...state.threads,\n                    [threadId]: removeReaction(\n                      existingThread,\n                      commentId,\n                      emoji,\n                      userId,\n                      removedAt\n                    ),\n                  },\n                  optimisticUpdates: updatedOptimisticUpdates,\n                };\n              });\n            },\n            (err: Error) =>\n              onMutationFailure(\n                err,\n                optimisticUpdateId,\n                (error) =>\n                  new RemoveReactionError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId,\n                    emoji,\n                  })\n              )\n          );\n      },\n      [room]\n    );\n  }\n\n  function useCreateComment(): (options: CreateCommentOptions) => CommentData {\n    const room = useRoom();\n    return React.useCallback(\n      ({ threadId, body }: CreateCommentOptions): CommentData => {\n        const commentId = createCommentId();\n        const createdAt = new Date();\n\n        const comment: CommentData = {\n          id: commentId,\n          threadId,\n          roomId: room.id,\n          type: \"comment\",\n          createdAt,\n          userId: getCurrentUserId(room),\n          body,\n          reactions: [],\n        };\n\n        const optimisticUpdateId = nanoid();\n\n        store.pushOptimisticUpdate({\n          type: \"create-comment\",\n          comment,\n          id: optimisticUpdateId,\n        });\n\n        room[kInternal].comments\n          .createComment({ threadId, commentId, body })\n          .then(\n            (newComment) => {\n              store.set((state) => {\n                const existingThread = state.threads[threadId];\n                const updatedOptimisticUpdates = state.optimisticUpdates.filter(\n                  (update) => update.id !== optimisticUpdateId\n                );\n\n                if (existingThread === undefined) {\n                  return {\n                    ...state,\n                    optimisticUpdates: updatedOptimisticUpdates,\n                  };\n                }\n\n                const inboxNotification = Object.values(\n                  state.inboxNotifications\n                ).find(\n                  (notification) =>\n                    notification.kind === \"thread\" &&\n                    notification.threadId === threadId\n                );\n\n                // If the thread has an inbox notification associated with it, we update the notification's `notifiedAt` and `readAt` values\n                const updatedInboxNotifications =\n                  inboxNotification !== undefined\n                    ? {\n                        ...state.inboxNotifications,\n                        [inboxNotification.id]: {\n                          ...inboxNotification,\n                          notifiedAt: newComment.createdAt,\n                          readAt: newComment.createdAt,\n                        },\n                      }\n                    : state.inboxNotifications;\n\n                return {\n                  ...state,\n                  threads: {\n                    ...state.threads,\n                    [threadId]: upsertComment(existingThread, newComment), // Upsert the new comment into the thread comments list (if applicable)\n                  },\n                  inboxNotifications: updatedInboxNotifications,\n                  optimisticUpdates: updatedOptimisticUpdates,\n                };\n              });\n            },\n            (err: Error) =>\n              onMutationFailure(\n                err,\n                optimisticUpdateId,\n                (err) =>\n                  new CreateCommentError(err, {\n                    roomId: room.id,\n                    threadId,\n                    commentId,\n                    body,\n                  })\n              )\n          );\n\n        return comment;\n      },\n      [room]\n    );\n  }\n\n  function useEditComment(): (options: EditCommentOptions) => void {\n    const room = useRoom();\n    return React.useCallback(\n      ({ threadId, commentId, body }: EditCommentOptions): void => {\n        const editedAt = new Date();\n        const optimisticUpdateId = nanoid();\n\n        const thread = store.get().threads[threadId];\n        if (thread === undefined) {\n          console.warn(\n            `Internal unexpected behavior. Cannot edit comment in thread \"${threadId}\" because the thread does not exist in the cache.`\n          );\n          return;\n        }\n\n        const comment = thread.comments.find(\n          (comment) => comment.id === commentId\n        );\n\n        if (comment === undefined || comment.deletedAt !== undefined) {\n          console.warn(\n            `Internal unexpected behavior. Cannot edit comment \"${commentId}\" in thread \"${threadId}\" because the comment does not exist in the cache.`\n          );\n          return;\n        }\n\n        store.pushOptimisticUpdate({\n          type: \"edit-comment\",\n          comment: {\n            ...comment,\n            editedAt,\n            body,\n          },\n          id: optimisticUpdateId,\n        });\n\n        room[kInternal].comments\n          .editComment({ threadId, commentId, body })\n          .then(\n            (editedComment) => {\n              store.set((state) => {\n                const existingThread = state.threads[threadId];\n                const updatedOptimisticUpdates = state.optimisticUpdates.filter(\n                  (update) => update.id !== optimisticUpdateId\n                );\n\n                if (existingThread === undefined) {\n                  return {\n                    ...state,\n                    optimisticUpdates: updatedOptimisticUpdates,\n                  };\n                }\n\n                return {\n                  ...state,\n                  threads: {\n                    ...state.threads,\n                    [threadId]: upsertComment(existingThread, editedComment), // Upsert the edited comment into the thread comments list (if applicable)\n                  },\n                  optimisticUpdates: updatedOptimisticUpdates,\n                };\n              });\n            },\n            (err: Error) =>\n              onMutationFailure(\n                err,\n                optimisticUpdateId,\n                (error) =>\n                  new EditCommentError(error, {\n                    roomId: room.id,\n                    threadId,\n                    commentId,\n                    body,\n                  })\n              )\n          );\n      },\n      [room]\n    );\n  }\n\n  function useDeleteComment() {\n    const room = useRoom();\n    return React.useCallback(\n      ({ threadId, commentId }: DeleteCommentOptions): void => {\n        const deletedAt = new Date();\n\n        const optimisticUpdateId = nanoid();\n\n        store.pushOptimisticUpdate({\n          type: \"delete-comment\",\n          threadId,\n          commentId,\n          deletedAt,\n          id: optimisticUpdateId,\n        });\n\n        room[kInternal].comments.deleteComment({ threadId, commentId }).then(\n          () => {\n            store.set((state) => {\n              const existingThread = state.threads[threadId];\n              const updatedOptimisticUpdates = state.optimisticUpdates.filter(\n                (update) => update.id !== optimisticUpdateId\n              );\n\n              // If thread does not exist, we return the existing state\n              if (existingThread === undefined) {\n                return {\n                  ...state,\n                  optimisticUpdates: updatedOptimisticUpdates,\n                };\n              }\n\n              return {\n                ...state,\n                threads: {\n                  ...state.threads,\n                  [threadId]: deleteComment(\n                    existingThread,\n                    commentId,\n                    deletedAt\n                  ),\n                },\n                optimisticUpdates: updatedOptimisticUpdates,\n              };\n            });\n          },\n          (err: Error) =>\n            onMutationFailure(\n              err,\n              optimisticUpdateId,\n              (error) =>\n                new DeleteCommentError(error, {\n                  roomId: room.id,\n                  threadId,\n                  commentId,\n                })\n            )\n        );\n      },\n      [room]\n    );\n  }\n\n  const resolveMentionSuggestions = client[kInternal].resolveMentionSuggestions;\n  const mentionSuggestionsCache = new Map<string, string[]>();\n\n  // Simplistic debounced search, we don't need to worry too much about\n  // deduping and race conditions as there can only be one search at a time.\n  function useMentionSuggestions(search?: string) {\n    const room = useRoom();\n    const [mentionSuggestions, setMentionSuggestions] =\n      React.useState<string[]>();\n    const lastInvokedAt = React.useRef<number>();\n\n    React.useEffect(() => {\n      if (search === undefined || !resolveMentionSuggestions) {\n        return;\n      }\n\n      const resolveMentionSuggestionsArgs = { text: search, roomId: room.id };\n      const mentionSuggestionsCacheKey = stringify(\n        resolveMentionSuggestionsArgs\n      );\n      let debounceTimeout: number | undefined;\n      let isCanceled = false;\n\n      const getMentionSuggestions = async () => {\n        try {\n          lastInvokedAt.current = performance.now();\n          const mentionSuggestions = await resolveMentionSuggestions(\n            resolveMentionSuggestionsArgs\n          );\n\n          if (!isCanceled) {\n            setMentionSuggestions(mentionSuggestions);\n            mentionSuggestionsCache.set(\n              mentionSuggestionsCacheKey,\n              mentionSuggestions\n            );\n          }\n        } catch (error) {\n          console.error((error as Error)?.message);\n        }\n      };\n\n      if (mentionSuggestionsCache.has(mentionSuggestionsCacheKey)) {\n        // If there are already cached mention suggestions, use them immediately.\n        setMentionSuggestions(\n          mentionSuggestionsCache.get(mentionSuggestionsCacheKey)\n        );\n      } else if (\n        !lastInvokedAt.current ||\n        Math.abs(performance.now() - lastInvokedAt.current) >\n          MENTION_SUGGESTIONS_DEBOUNCE\n      ) {\n        // If on the debounce's leading edge (either because it's the first invokation or enough\n        // time has passed since the last debounce), get mention suggestions immediately.\n        void getMentionSuggestions();\n      } else {\n        // Otherwise, wait for the debounce delay.\n        debounceTimeout = window.setTimeout(() => {\n          void getMentionSuggestions();\n        }, MENTION_SUGGESTIONS_DEBOUNCE);\n      }\n\n      return () => {\n        isCanceled = true;\n        window.clearTimeout(debounceTimeout);\n      };\n    }, [room.id, search]);\n\n    return mentionSuggestions;\n  }\n\n  function useThreadSubscription(threadId: string): ThreadSubscription {\n    const selector = React.useCallback(\n      (state: CacheState<BaseMetadata>): ThreadSubscription => {\n        const inboxNotification = selectedInboxNotifications(state).find(\n          (inboxNotification) =>\n            inboxNotification.kind === \"thread\" &&\n            inboxNotification.threadId === threadId\n        );\n\n        const thread = state.threads[threadId];\n\n        if (inboxNotification === undefined || thread === undefined) {\n          return {\n            status: \"not-subscribed\",\n          };\n        }\n\n        return {\n          status: \"subscribed\",\n          unreadSince: inboxNotification.readAt,\n        };\n      },\n      [threadId]\n    );\n\n    return useSyncExternalStoreWithSelector(\n      store.subscribe,\n      store.get,\n      store.get,\n      selector\n    );\n  }\n\n  function useMarkThreadAsRead() {\n    const room = useRoom();\n\n    return React.useCallback(\n      (threadId: string) => {\n        const inboxNotification = Object.values(\n          store.get().inboxNotifications\n        ).find(\n          (inboxNotification) =>\n            inboxNotification.kind === \"thread\" &&\n            inboxNotification.threadId === threadId\n        );\n\n        if (!inboxNotification) return;\n\n        const optimisticUpdateId = nanoid();\n        const now = new Date();\n\n        store.pushOptimisticUpdate({\n          type: \"mark-inbox-notification-as-read\",\n          id: optimisticUpdateId,\n          inboxNotificationId: inboxNotification.id,\n          readAt: now,\n        });\n\n        room[kInternal].notifications\n          .markInboxNotificationAsRead(inboxNotification.id)\n          .then(\n            () => {\n              store.set((state) => ({\n                ...state,\n                inboxNotifications: {\n                  ...state.inboxNotifications,\n                  [inboxNotification.id]: {\n                    ...inboxNotification,\n                    readAt: now,\n                  },\n                },\n                optimisticUpdates: state.optimisticUpdates.filter(\n                  (update) => update.id !== optimisticUpdateId\n                ),\n              }));\n            },\n            (err: Error) => {\n              onMutationFailure(\n                err,\n                optimisticUpdateId,\n                (error) =>\n                  new MarkInboxNotificationAsReadError(error, {\n                    inboxNotificationId: inboxNotification.id,\n                  })\n              );\n              return;\n            }\n          );\n      },\n      [room]\n    );\n  }\n\n  function makeNotificationSettingsQueryKey(roomId: string) {\n    return `${roomId}:NOTIFICATION_SETTINGS`;\n  }\n\n  async function getInboxNotificationSettings(\n    room: Room<JsonObject, LsonObject, BaseUserMeta, Json>,\n    queryKey: string,\n    { retryCount }: { retryCount: number } = { retryCount: 0 }\n  ) {\n    const existingRequest = requestsByQuery.get(queryKey);\n\n    // If a request was already made for the notifications query, we do not make another request and return the existing promise\n    if (existingRequest !== undefined) return existingRequest;\n\n    try {\n      const request =\n        room[kInternal].notifications.getRoomNotificationSettings();\n\n      requestsByQuery.set(queryKey, request);\n\n      store.setQueryState(queryKey, {\n        isLoading: true,\n      });\n\n      const settings = await request;\n      store.updateRoomInboxNotificationSettings(room.id, settings, queryKey);\n    } catch (err) {\n      requestsByQuery.delete(queryKey);\n\n      retryError(() => {\n        void getInboxNotificationSettings(room, queryKey, {\n          retryCount: retryCount + 1,\n        });\n      }, retryCount);\n\n      store.setQueryState(queryKey, {\n        isLoading: false,\n        error: err as Error,\n      });\n\n      return;\n    }\n  }\n\n  function useRoomNotificationSettings(): [\n    RoomNotificationSettingsState,\n    (settings: Partial<RoomNotificationSettings>) => void,\n  ] {\n    const room = useRoom();\n\n    React.useEffect(() => {\n      const queryKey = makeNotificationSettingsQueryKey(room.id);\n      void getInboxNotificationSettings(room, queryKey);\n    }, [room]);\n\n    const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();\n\n    const selector = React.useCallback(\n      (state: CacheState<BaseMetadata>): RoomNotificationSettingsState => {\n        const query = state.queries[makeNotificationSettingsQueryKey(room.id)];\n\n        if (query === undefined || query.isLoading) {\n          return { isLoading: true };\n        }\n\n        if (query.error !== undefined) {\n          return { isLoading: false, error: query.error };\n        }\n\n        return {\n          isLoading: false,\n          settings: selectNotificationSettings(room.id, state),\n        };\n      },\n      [room]\n    );\n\n    const settings = useSyncExternalStoreWithSelector(\n      store.subscribe,\n      store.get,\n      store.get,\n      selector\n    );\n\n    return React.useMemo(() => {\n      return [settings, updateRoomNotificationSettings];\n    }, [settings, updateRoomNotificationSettings]);\n  }\n\n  function useRoomNotificationSettingsSuspense(): [\n    RoomNotificationSettingsStateSuccess,\n    (settings: Partial<RoomNotificationSettings>) => void,\n  ] {\n    const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();\n    const room = useRoom();\n    const queryKey = makeNotificationSettingsQueryKey(room.id);\n    const query = store.get().queries[queryKey];\n\n    if (query === undefined || query.isLoading) {\n      throw getInboxNotificationSettings(room, queryKey);\n    }\n\n    if (query.error) {\n      throw query.error;\n    }\n\n    const selector = React.useCallback(\n      (\n        state: CacheState<BaseMetadata>\n      ): RoomNotificationSettingsStateSuccess => {\n        return {\n          isLoading: false,\n          settings: selectNotificationSettings(room.id, state),\n        };\n      },\n      [room]\n    );\n\n    const settings = useSyncExternalStoreWithSelector(\n      store.subscribe,\n      store.get,\n      store.get,\n      selector\n    );\n\n    return React.useMemo(() => {\n      return [settings, updateRoomNotificationSettings];\n    }, [settings, updateRoomNotificationSettings]);\n  }\n\n  function useUpdateRoomNotificationSettings() {\n    const room = useRoom();\n    return React.useCallback(\n      (settings: Partial<RoomNotificationSettings>) => {\n        const optimisticUpdateId = nanoid();\n\n        store.pushOptimisticUpdate({\n          id: optimisticUpdateId,\n          type: \"update-notification-settings\",\n          roomId: room.id,\n          settings,\n        });\n\n        room[kInternal].notifications\n          .updateRoomNotificationSettings(settings)\n          .then(\n            (settings) => {\n              store.set((state) => ({\n                ...state,\n                notificationSettings: {\n                  [room.id]: settings,\n                },\n                optimisticUpdates: state.optimisticUpdates.filter(\n                  (update) => update.id !== optimisticUpdateId\n                ),\n              }));\n            },\n            (err: Error) =>\n              onMutationFailure(\n                err,\n                optimisticUpdateId,\n                (error) =>\n                  new UpdateNotificationSettingsError(error, {\n                    roomId: room.id,\n                  })\n              )\n          );\n      },\n      [room]\n    );\n  }\n\n  function useCurrentUserId() {\n    return useSelf((user) => (typeof user.id === \"string\" ? user.id : null));\n  }\n\n  const bundle: RoomContextBundle<\n    TPresence,\n    TStorage,\n    TUserMeta,\n    TRoomEvent,\n    TThreadMetadata\n  > = {\n    RoomContext,\n    RoomProvider: RoomProviderOuter,\n\n    useRoom,\n    useStatus,\n\n    useBatch,\n    useBroadcastEvent,\n    useOthersListener,\n    useLostConnectionListener,\n    useErrorListener,\n    useEventListener,\n\n    useHistory,\n    useUndo,\n    useRedo,\n    useCanRedo,\n    useCanUndo,\n\n    // These are just aliases. The passed-in key will define their return values.\n    useList: useLegacyKey,\n    useMap: useLegacyKey,\n    useObject: useLegacyKey,\n\n    useStorageRoot,\n    useStorage,\n\n    useSelf,\n    useMyPresence,\n    useUpdateMyPresence,\n    useOthers,\n    useOthersMapped,\n    useOthersConnectionIds,\n    useOther,\n\n    useMutation,\n\n    useThreads,\n\n    useCreateThread,\n    useEditThreadMetadata,\n    useCreateComment,\n    useEditComment,\n    useDeleteComment,\n    useAddReaction,\n    useRemoveReaction,\n    useMarkThreadAsRead,\n    useThreadSubscription,\n\n    useRoomNotificationSettings,\n    useUpdateRoomNotificationSettings,\n\n    ...shared,\n\n    suspense: {\n      RoomContext,\n      RoomProvider: RoomProviderOuter,\n\n      useRoom,\n      useStatus,\n\n      useBatch,\n      useBroadcastEvent,\n      useOthersListener,\n      useLostConnectionListener,\n      useErrorListener,\n      useEventListener,\n\n      useHistory,\n      useUndo,\n      useRedo,\n      useCanRedo,\n      useCanUndo,\n\n      // Legacy hooks\n      useList: useLegacyKeySuspense,\n      useMap: useLegacyKeySuspense,\n      useObject: useLegacyKeySuspense,\n\n      useStorageRoot,\n      useStorage: useStorageSuspense,\n\n      useSelf: useSelfSuspense,\n      useMyPresence,\n      useUpdateMyPresence,\n      useOthers: useOthersSuspense,\n      useOthersMapped: useOthersMappedSuspense,\n      useOthersConnectionIds: useOthersConnectionIdsSuspense,\n      useOther: useOtherSuspense,\n\n      useMutation,\n\n      useThreads: useThreadsSuspense,\n\n      useCreateThread,\n      useEditThreadMetadata,\n      useCreateComment,\n      useEditComment,\n      useDeleteComment,\n      useAddReaction,\n      useRemoveReaction,\n      useMarkThreadAsRead,\n      useThreadSubscription,\n\n      useRoomNotificationSettings: useRoomNotificationSettingsSuspense,\n      useUpdateRoomNotificationSettings,\n\n      ...shared.suspense,\n    },\n\n    [kInternal]: {\n      useCurrentUserId,\n      hasResolveMentionSuggestions: resolveMentionSuggestions !== undefined,\n      useMentionSuggestions,\n    },\n  };\n\n  return Object.defineProperty(bundle, kInternal, {\n    enumerable: false,\n  });\n}\n\nfunction getCurrentUserId(\n  room: Room<JsonObject, LsonObject, BaseUserMeta, Json>\n): string {\n  const self = room.getSelf();\n  if (self === null || self.id === undefined) {\n    return \"anonymous\";\n  } else {\n    return self.id;\n  }\n}\n\nfunction handleApiError(err: CommentsApiError | NotificationsApiError): Error {\n  const message = `Request failed with status ${err.status}: ${err.message}`;\n\n  // Log details about FORBIDDEN errors\n  if (err.details?.error === \"FORBIDDEN\") {\n    const detailedMessage = [message, err.details.suggestion, err.details.docs]\n      .filter(Boolean)\n      .join(\"\\n\");\n\n    console.error(detailedMessage);\n  }\n\n  return new Error(message);\n}\n\nexport function generateQueryKey<TThreadMetadata extends BaseMetadata>(\n  roomId: string,\n  options: UseThreadsOptions<TThreadMetadata>[\"query\"]\n) {\n  return `${roomId}-${stringify(options ?? {})}`;\n}\n","import type {\n  BaseMetadata,\n  CommentBody,\n  PartialNullable,\n} from \"@liveblocks/core\";\n\nexport class CreateThreadError<TMetadata extends BaseMetadata> extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      body: CommentBody;\n      metadata: TMetadata;\n    }\n  ) {\n    super(\"Create thread failed.\");\n    this.name = \"CreateThreadError\";\n  }\n}\n\nexport class EditThreadMetadataError<\n  TMetadata extends BaseMetadata,\n> extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      metadata: PartialNullable<TMetadata>;\n    }\n  ) {\n    super(\"Edit thread metadata failed.\");\n    this.name = \"EditThreadMetadataError\";\n  }\n}\n\nexport class CreateCommentError extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      body: CommentBody;\n    }\n  ) {\n    super(\"Create comment failed.\");\n    this.name = \"CreateCommentError\";\n  }\n}\n\nexport class EditCommentError extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      body: CommentBody;\n    }\n  ) {\n    super(\"Edit comment failed.\");\n    this.name = \"EditCommentError\";\n  }\n}\n\nexport class DeleteCommentError extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      commentId: string;\n    }\n  ) {\n    super(\"Delete comment failed.\");\n    this.name = \"DeleteCommentError\";\n  }\n}\n\nexport class AddReactionError extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      emoji: string;\n    }\n  ) {\n    super(\"Add reaction failed.\");\n    this.name = \"AddReactionError\";\n  }\n}\n\nexport class RemoveReactionError extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      emoji: string;\n    }\n  ) {\n    super(\"Remove reaction failed.\");\n    this.name = \"RemoveReactionError\";\n  }\n}\n\nexport class MarkInboxNotificationAsReadError extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      inboxNotificationId: string;\n    }\n  ) {\n    super(\"Mark inbox notification as read failed.\");\n    this.name = \"MarkInboxNotificationAsReadError\";\n  }\n}\n\nexport class UpdateNotificationSettingsError extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n    }\n  ) {\n    super(\"Update notification settings failed.\");\n    this.name = \"UpdateNotificationSettingsError\";\n  }\n}\n\nexport type CommentsError<TThreadMetadata extends BaseMetadata> =\n  | CreateThreadError<TThreadMetadata>\n  | EditThreadMetadataError<TThreadMetadata>\n  | CreateCommentError\n  | EditCommentError\n  | DeleteCommentError\n  | MarkInboxNotificationAsReadError\n  | UpdateNotificationSettingsError;\n","import { nanoid } from \"nanoid\";\n\nconst THREAD_ID_PREFIX = \"th\";\nconst COMMENT_ID_PREFIX = \"cm\";\nconst INBOX_NOTIFICATION_ID_PREFIX = \"in\";\n\nfunction createOptimisticId(prefix: string) {\n  return `${prefix}_${nanoid()}`;\n}\n\nexport function createThreadId() {\n  return createOptimisticId(THREAD_ID_PREFIX);\n}\n\nexport function createCommentId() {\n  return createOptimisticId(COMMENT_ID_PREFIX);\n}\n\nexport function createInboxNotificationId() {\n  return createOptimisticId(INBOX_NOTIFICATION_ID_PREFIX);\n}\n","import {\n  applyOptimisticUpdates,\n  type BaseMetadata,\n  type CacheState,\n  nn,\n  type RoomNotificationSettings,\n} from \"@liveblocks/core\";\n\nexport function selectNotificationSettings<\n  TThreadMetadata extends BaseMetadata,\n>(\n  roomId: string,\n  state: CacheState<TThreadMetadata>\n): RoomNotificationSettings {\n  const { notificationSettings } = applyOptimisticUpdates(state);\n  return nn(notificationSettings[roomId]);\n}\n","import {\n  applyOptimisticUpdates,\n  type BaseMetadata,\n  type CacheState,\n  type ThreadData,\n} from \"@liveblocks/core\";\n\nimport type { UseThreadsOptions } from \"../../types\";\n\nexport function selectedThreads<TThreadMetadata extends BaseMetadata>(\n  roomId: string,\n  state: CacheState<TThreadMetadata>,\n  options: UseThreadsOptions<TThreadMetadata>\n): ThreadData<TThreadMetadata>[] {\n  const result = applyOptimisticUpdates(state);\n\n  // Filter threads to only include the non-deleted threads from the specified room and that match the specified filter options\n  const threads = Object.values(result.threads).filter<\n    ThreadData<TThreadMetadata>\n  >((thread): thread is ThreadData<TThreadMetadata> => {\n    if (thread.roomId !== roomId) return false;\n\n    // We do not want to include threads that have been marked as deleted\n    if (thread.deletedAt !== undefined) {\n      return false;\n    }\n\n    const query = options.query;\n    if (!query) return true;\n\n    for (const key in query.metadata) {\n      const metadataValue = thread.metadata[key];\n      const filterValue = query.metadata[key];\n\n      if (\n        assertFilterIsStartsWithOperator(filterValue) &&\n        assertMetadataValueIsString(metadataValue)\n      ) {\n        if (metadataValue.startsWith(filterValue.startsWith)) {\n          return true;\n        }\n      }\n\n      if (metadataValue !== filterValue) {\n        return false;\n      }\n    }\n\n    return true;\n  });\n\n  // Sort threads by creation date (oldest first)\n  return threads.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\n}\n\nconst assertFilterIsStartsWithOperator = (\n  filter: boolean | string | number | undefined | { startsWith: string }\n): filter is { startsWith: string } => {\n  if (typeof filter === \"object\" && typeof filter.startsWith === \"string\") {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nconst assertMetadataValueIsString = (value: any): value is string => {\n  return typeof value === \"string\";\n};\n","import { useState } from \"react\";\n\n/**\n * \"Freezes\" a given value, so that it will return the same value/instance on\n * each subsequent render. This can be used to freeze \"initial\" values for\n * custom hooks, much like how `useState(initialState)` or\n * `useRef(initialValue)` works.\n */\nexport function useInitial<T>(value: T): T {\n  return useState(value)[0];\n}\n","import { useEffect, useRef } from \"react\";\n\n/**\n * Keeps a ref in sync with a given value that may or may not change on\n * every render.\n *\n * The purpose of this hook is to return a stable ref that can be passed\n * to a callback function so the callback can be registered but still can\n * access the latest value at a later point in time.\n */\nexport function useLatest<T>(value: T): { readonly current: T } {\n  const ref = useRef(value);\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref;\n}\n","import { useReducer } from \"react\";\n\n/**\n * Trigger a re-render programmatically, without changing the component's\n * state.\n *\n * @example\n * const rerender = useRerender();\n *\n * return (\n *   <button onClick={rerender}>\n *     {Math.random()}\n *   </button>\n * )\n */\nexport function useRerender(): () => void {\n  const [, update] = useReducer(\n    // This implementation works by incrementing a hidden counter value that is\n    // never consumed. Simply incrementing the counter changes the component's\n    // state and, thus, trigger a re-render.\n    (x: number): number => x + 1,\n    0\n  );\n  return update;\n}\n"]}